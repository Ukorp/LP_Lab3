#№ Отчет по лабораторной работе №3
## по курсу "Логическое программирование"

## Решение задач методом поиска в пространстве состояний

### студент: Сафин Т. А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Какие задачи удобным образом решаются методом поиска в пространстве состояний? 

Лучше всего метод поиска в пространстве состояний работает с задачами, в которых можно определить это пространство, а также начальные и конечные состояния, переходы от одного состояния к другому. Таким образом, это те задачи, которые можно свести к поиску решений в графе. 

Почему Prolog оказывается удобным языком для решения таких задач?

В языке Prolog очень удобно задавать состояния в виде предикатов. Кроме того, сам Prolog использует один из методов поиска - поиск в глубину. Это делает использование данного метода простым и естественным, хоть и не оптимальным.

## Задание

3. Железнодорожный сортировочный узел устроен так, как показано на
рисунке. На левой стороне собрано некоторое число вагонов двух типов
(черные и белые), обоих типов по n штук., в произвольном порядке
Тупик вмещает все 2n вагонов. Пользуясь тремя сортировочными
операциями (слева в тупик, из тупика направо, слева направо, минуя
тупик), собрать вагоны на левой стороне, так, чтобы типы чередовались.
Для решения задачи достаточно 3n-1 сортировочных операций.

## Принцип решения

Изначальное состояние описывается пользователем - это список из черных и белых вагонов, расставленных в произвольном порядке. Переходы между состояниями тоже четко определены - сдвиг вагона слева в тупик, из тупика направо и слева направо. Из - за того, что все операции двигают вагоны лишь в одном направлении, то нет необходимости создавать предохранитель от зацикливания - оно попросту невозможно. 

Использовались алгоритмы: поиска в глубину, в ширину, в глубину с ограничением, в глубину с итеративным погружением.

Для каждого из них реализовано по два предиката - рабочий и "обертка".

В глубину:

Предикат - "обертка". Вызывает вспомогательный предикат goal, для получения конечного состояния и рабочий предикат dpath.

```
prolog
dpath(X, R) :-
    goal(X, G),
    dpath([[X, [], []]], [[], [], G], R1),
    reverse(R1, R).
```
 
Рабочий предикат. Рекурсивно вызывает вспомогательный предикат prolong, пытающийся продлить путь.
```
prolog
dpath([H | T], H, [H | T]).
dpath(P, G, R) :-
   prolong(P, P1),
   dpath(P1, G, R).
```

В ширину:

Предикат - "обертка". Использует вспомогательный предикат extra, необходимый для походового вывода решения.
```
prolog
wpath(S, R) :-
   goal(S, G),
   wpath1([[[S, [], []]]], [[], [], G], R1),
   !,
   reverse(R1, R2),
   extra(R2, R).
```
 
Рабочий предикат. Использует вспомогательный предикат mfindall, который отличается от стандартного лишь выводом пустого списка при отсутствии решений.
```
prolog
wpath1([[H | T] | _], H, [H | T]).
wpath1([H | Qin], G, R) :-
   mfindall(H, L),
   append(Qin, L, Qout),
   wpath1(Qout, G, R).
```

В глубину с ограничением глубины:

Предикат - "обертка". Находит количество вагонов и использует количество 3n - 1 в качестве ограничителя.
```
prolog
dcpath(X, R) :-
    goal(X, G),
    length(G, C1),
    C is (3 * C1 / 2) - 1,
    dcpath1([[X, [], []]], [[], [], G], R1, C), !,
    reverse(R1, R2),
    extra(R2, R).
```
 
Рабочий предикат. Выполняет поиск в глубину до тех пор, пока длина решения не превышает ограничитель.
```
prolog
dcpath1([H | T], H, [H | T], _).
dcpath1(P, G, R, C) :-
    C > 0,
    prolong(P, P1), 
    C1 is C - 1,
    dcpath1(P1, G, R, C1).
```

В глубину с итеративным погружением:

Предикат - "обертка". Как видно, поиск с итеративным погружением использует рабочий предикат поиска с ограничением глубины, однако каждый раз передает ему новое число, которое генерируется вспомогательным предикатом int.
```
prolog
dipath(X, R) :- 
    goal(X, G),
    int(CC),
    dcpath1([[X, [], []]], [[], [], G], R1, CC), !,
    reverse(R1, R2), 
    extra(R2, R).
```

## Результаты

! Алгоритм поиска |  Длина найденного первым пути  |  Время работы                                                     |
|----------------------------------------------------------------------------------------------------------------------|
| В глубину       |                 12             |                    w, w, w, w, b, b, b, b                         |
| В ширину        |                 12             |                    w, w, w, w, b, b, b, b                         |
| ID              |                 12             |                    w, w, w, w, b, b, b, b                         |
|-----------------------------------------------------------------------------------------------------------------------
| В глубину       |                 24             |        b, b, w, w, w, b, w, w, b, b, w, b, b, b, b, w, w, w       |
| В ширину        |                 -              |        b, b, w, w, w, b, w, w, b, b, w, b, b, b, b, w, w, w       |
| ID              |                 23             |        b, b, w, w, w, b, w, w, b, b, w, b, b, b, b, w, w, w       |
|-----------------------------------------------------------------------------------------------------------------------

## Выводы

Данная лабораторная работа научила меня нескольким вещам. Во-первых, использование предикатов-"оберток" существенно упрощает взаимодействие пользователя с программой и предикатов друг с другом. Во-вторых, правильно написанная программа может решать задачи на поиск в пространстве состояний даже эффективнее человека, так как способна проверять абсолютно все варианты действий. Так, например, оказалось, что у моей задачи в определенных условиях может быть несколько кратчайших решений, хотя их различия минимальны. 
В-третьих, поиск с итеративным погружением в некоторых случаях (например в моем) может быть неэффективен. Это связано с тем, что длина решения в моей задаче не может быть меньше чем 2n. Таким образом, поиск с итеративным погружением находит примерно 4n^3 - 2n^2 лишних неполных решений различной длины.




